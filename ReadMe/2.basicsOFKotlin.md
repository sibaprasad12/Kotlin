# Basics Of Kotlin
## Basic Syntax
- **var** keyword used for variable declaration  
- ```var a``` // it will show error  
- because if u declare a variable without any datatytpe, then you have to assign some value to the variable  
- var a = 123 // it will not show any error    
- var is only to declare not null type variables, we cant assign any null value to the variable declared as var
- it will show error - null cant be the value of a non null type  
  
## val
- keyword used to define any constants value  
- its nothing but the **final** keyword in java
- the value cant be changed
```
let a = 123
let variable:Int = 123434
```
## Difference between const and val
- **consts** are compile time constants. Meaning that their value has to be assigned during compile time, unlike vals, where it can be done at runtime.
- This means, that **consts** can never be assigned to a function or any class constructor, but only to a String or primitive.
- const val are allowed only in top level or in objects
- For example:
```
const val foo = complexFunctionCall()   //Not okay
val fooVal = complexFunctionCall()  //Okay
const val bar = "Hello world"           //Also okay
```
## **? and !! operator**  
- We can declare any variable using **?** and **!!** operator or without using any operator at all.   
- **var a:String? ="abc"**, when we declare any variable with ? operator, this means , the variable can be null anytime. We use ? operator for null safety. We have to assign value to the variable we declare with ? and also have to define the datatype of the variable. Otherwise it will show compile time error.
- ```print(a?.length())``` - if a is null , it will print nothing  
- Else it will print the length of the string  
- At the compile time, the compiler force us to handle the null pointer while doing any operation on the null values like 
- when we declare any variable like , question mark after the Datatype. that means you are saying that the value may be null some time.
```var a:String? ="abc"```
- here we are saying the compiler that the variable a can hold null.When we will do any operation on the variable a, the compiler will show compilertime error to handle null pointer exception.  
```
println(a.length)  // it will show compile time error that the value can be null  
println(a!!.length) // it will not show any error now, because we handle Null pointer exceptin  
```
- In the above case if a is null, it will through null pointer exception. If we handle using try cache, it will be okay else it will crash.  
```  
fun parseInt(str: String): Int? {  
    // ...  
}  
```
- This function explains that the return type can be null, so you have to handle
## variable without ? operator 
```
var a:String = "SIba"
a = null// it will show compile time error saying that the variable can be null.  
```  
## Use of !! - null assertion operator (!!)**  
- The third option is for NPE-lovers: the not-null assertion operator (!!) converts any value to a non-null type and throws an exception if the value is null. 
- We can write b!!, and this will return a non-null value of b (e.g., a String in our example) or throw an NPE if b is null:  
 - ```val l = b!!.length```  
- Thus, if you want an NPE, you can have it, but you have to ask for it explicitly, and it does not appear out of the blue.   
## late init
- when we declare any variable as lateinit, this means the variable will be initialize later. 
- If the variable is not assigned any value and we trying to use the variable, it will show runtime error. that is lateinit property variableName has not been initialized
- Here is how to declare lateinit variable
```
lateinit var name1:String
```
- here is the example how to use it
```
println(name1.length) // it will show runtime error , that the variable is not initialized or assigned any value
name1 = "Sibaprasad"  
println(name1.length)  // it will print the length of the variable without any error. because this variable is assigned value later with "Sibaprasad"  
```
## Here are the DataType List and their Range  
**Type**	     **Bit width*  
 Double       64(Bit)  
 Float        32(Bit)    
 Long         64(Bit)    
 Int          32(Bit)    
 Short        16(Bit)    
 Byte          8(Bit)    

**NOTE:Underscores in numeric literals (since 1.1)**  
- You can use underscores to make number constants more readable:  
- *ForExample*  
```
val oneMillion = 1_000_000  
val creditCardNumber = 1234_5678_9012_3456L  
val socialSecurityNumber = 999_99_9999L  
val hexBytes = 0xFF_EC_DE_5E  
val bytes = 0b11010010_01101001_10010100_10010010    
```
**NOTE :** Kotlin doesnot support implicit type coversion, It supports only explicit data conversion 
- For example  
```
var a:Int = 123
var b:Long = a // it will show error
var b:Long = a.ToLong() // it will execute successfully  
```  
## Every number type supports the following conversions:  
**toByte(): Byte    
toShort(): Short  
toInt(): Int  
toLong(): Long  
toFloat(): Float  
toDouble(): Double  
toChar(): Char**  
## Type Checks and Casts: 'is' and 'as'
- is and !is Operators
- We can check whether an object conforms to a given type at runtime by using the is operator or its negated form !is:
```
if (obj is String) {
    print(obj.length)
}
​
if (obj !is String) { // same as !(obj is String)
    print("Not a String")
}
else {
    print(obj.length)
}
```
- **Unsafe cast operator as**
- val x: String = y as String
- **Safe Cast operator as?**
- val x: String? = y as String?
- **Nullable cast Operator as**
- val x: String? = y as? String
## Operators
- Here is the complete list of bitwise operations (available for Int and Long only):  
- **shl(bits)** – signed shift left (Java's <<)  
- **shr(bits)** – signed shift right (Java's >>)  
- **ushr(bits)** – unsigned shift right (Java's >>>)  
- **and(bits)** – bitwise and  
- **or(bits)** – bitwise or  
- **xor(bits)** – bitwise xor  
- **inv()** – bitwise inversion  
 
Here is a short overview of what each function accepts and returns:
  
**SAME PARAMETER	DIFFERENT RESULT**
**it 	     also      	let
**this	    apply	    run, with**  
- I was not particularly happy with the decision of standard library designers putting so many similar functions in, as they represent cognitive overload spm.kotlin.world.when analyzing the code. However, if you strictly use them for their intended purpose, they will state your intent and make the code more readable:

## Scope Functions
- For more details follow **https://kotlinlang.org/docs/reference/scope-functions.html**
## also
- additional processing on an object in a call chain  

## apply
- post-construction configuration  

## let 
- conversion of value  

## run
- execute lambdas with side-effects and no result  

## with 
- configure objects created somewhere else  

## takeIf and takeUnless
- When called on an object with a predicate provided, takeIf returns this object if it matches the predicate. Otherwise, it returns null. So, takeIf is a filtering function for a single object. 
- In turn, takeUnless returns the object if it doesn't match the predicate and null if it does. The object is available as a lambda argument (it).

- Be careful when using these functions to avoid potential problems. Do not use with on nullable variables. 
- Avoid nesting apply, run, and with, as you will not know the current this. For nested also and let, use a named parameter instead of it for the same reason. 
- Avoid it in long call chains, as it is not clear what it represents.
- For examples, please follow the link below  
**https://dzone.com/articles/examining-kotlins-also-apply-let-run-and-with-intentions**

**The operations on floating point numbers discussed in this section are:**    

Equality checks: a == b and a != b  
Comparison operators: a < b, a > b, a <= b, a >= b  
Range instantiation and range checks: a..b, x in a..b, x !in a..b  

**Arrays**  
Arrays in Kotlin are represented by the Array class, that has get and set functions (that turn into [] by operator overloading conventions), and size property, along with a few other useful member functions:  
// Creates an Array<String> with values ["0", "1", "4", "9", "16"]  
val asc = Array(5, { i -> (i * i).toString() })  
    
**String**    
Now we can use """ for below  
val text = """  
    for (c in "foo")  
        print(c)  
"""  
Or
this type of String also  
val text = """  
    |Tell me and I forget.  
    |Teach me and I remember.  
    |Involve me and I learn.  
    |(Benjamin Franklin)  
    """.trimMargin()  
**Note** By default | is used as margin prefix, but you can choose another character and pass it as a parameter, like trimMargin(">").  