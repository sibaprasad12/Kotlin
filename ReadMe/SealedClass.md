# SEALED CLASS- Lets explain the Problem- To handle the states of an API request we might have used enum classes.- Enum in Java is a data type that contains a fixed set of constants.- Itâ€™s a special data type that enables a variable to be a set full of predefined constants.- Its variable must be equal to one of the values that have been predefined for it.```public enum Response{    SUCCESS,    FAILURE}```- In the above example, it's constant. we can not change the content inside the each- In this case, we don't have any other details except SUCCESS and FAILURE- A response an have failure message and success message as well like this```enum class Response1(msg: String) {      SUCCESS("SUCCESS"),      FAILURE(exception:Exception) // This was not allowed}```- This is not possible with the help of enum-- Application have lots of states - fail, success, progress- It works in MVVM, MVI, MVP- Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a  limited set, but can not have any other type. They are, i a sense, an extension of enum classes : the set of values  for an enum type is also restricted, but each enum constant exists only as single instance, whereas a subclass of a  sealed class can have multiple instances which can contain state.- There are the properties    - Restricted hierarchies    - Set    - Types    - Contain Values- Basic example```sealed class Result {    class Success(val items: List<String>) : Result()    class Failure(val error: Throwable) : Result()}```  ```when(result){    is Result.Success -> showItems(result.items)    is Result.Failure -> result.error.printStackTrace()}```- In above when statement dont have any else clause because compiler knows that it only have 2 values- If you add another class inside Result then when clause will show error.```sealed class Result {    class Success(val items: List<String>) : Result()    class Failure(val error: Throwable) : Result()    class Cancelled(val msg: String) : Result()}```  ```when(result){    is Result.Success -> showItems(result.items)    is Result.Failure -> result.error.printStackTrace()    is Result.Cancelled -> println("Cancelled")}```     