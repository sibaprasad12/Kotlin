package spm.kotlin.world.higherOrderFunctionsfun main(args: Array<String>) {    val program = Program()    program.addTowNumbers(2,3)    program.addTowNumbers(3,5, object : MyInterface{        override fun execute(sum: Int) {            println(sum) // body        }    })    val test: String = "Hello"    val myLambda: (Int) -> Unit = {s:Int -> println(s)}    program.addTowNumbers(1,2, myLambda)}class Program{    fun addTowNumbers(a : Int, b: Int){        val sum = a+b        println(sum) // body    }    fun addTowNumbers(a : Int, b: Int, action : MyInterface){        val sum = a+b        action.execute(sum)    }    /**     * calling function with lambda expression     * the 3rd parameter will be of type MyLambda - (Int) -> Unit     */    fun addTowNumbers(a : Int, b: Int, action : (Int) -> Unit){        val sum = a+b        action(sum)    }}interface MyInterface{    fun execute(sum: Int)}