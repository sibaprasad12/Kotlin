package spm.kotlin.world.higherOrderFunctionsfun main(args: Array<String>) {    val program = Program()    program.addTowNumbers(2, 3)    program.addTowNumbers(3, 5, object : MyInterface {        override fun execute(sum: Int) {            println("sum by using interface $sum") // body        }    })    val test: String = "spm.kotlin.world.basic.Hello"    val myLambda: (Int) -> Unit = { s: Int -> println("Print using myLambda  $s") }    val myLambda12: (Int) -> Unit = { println("Print using myLambda 12 $it") }    // another way    val myLambda1: (Int, Int) -> Int = { a: Int, b: Int -> a + b }    program.addTowNumbers(2, 4, myLambda)    program.addTowNumbers(2, 4, myLambda12)    // another way    program.addTowNumbers(10, 20, { a, b -> a + b })    // another way    program.addTowNumbers(30, 20) { a, b -> a + b }}class Program{    fun addTowNumbers(a : Int, b: Int){        val sum = a+b        println(sum) // body    }    fun addTowNumbers(a : Int, b: Int, action : MyInterface){        val sum = a+b        action.execute(sum)    }    /**     * calling function with lambda expression     * the 3rd parameter will be of type MyLambda - (Int) -> Unit     */    fun addTowNumbers(a: Int, b: Int, action: (Int) -> Unit) {        // val myLambda : (Int) -> Unit = { s : Int -> println(s) }        val sum = a + b        action(sum)    }    // another way    fun addTowNumbers(a: Int, b: Int, action: (Int, Int) -> Int) {        val result = action(a, b)        println(result)    }}interface MyInterface{    fun execute(sum: Int)}