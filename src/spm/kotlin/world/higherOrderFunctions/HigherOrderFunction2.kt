package spm.kotlin.world.higherOrderFunctionsimport spm.kotlin.world.dataClass.User/** * * https://blog.mindorks.com/understanding-higher-order-functions-and-lambdas-in-kotlin * * A higher-order function is a function that takes functions as parameters or returns a function.It's a function which can take do two things:- Can take functions as parameters- Can return a functionLETS explain the first one -  can take functions as parameterfun passMeFunction(abc: () -> Unit) {// I can take function// do something here// execute the functionabc()} */var lambda1 = { println("Higher Order function without any parameter") }// higher-order functionfun higherfunc1(lmbd: () -> Unit) {     // accepting lambda as parameter    lmbd()                               //invokes lambda expression}val lambda2: (Int, Int) -> Int = { a, b -> a + b }var lambda_2 = { a: Int, b: Int -> a + b }fun hugherOrderFun2(lambda: (Int, Int) -> Int) {    val res = lambda(2, 4)    println("Sum using Higher Order function is $res")}fun printMe(s: String): Unit {    println(s)}// higher-order function definitionfun higherfuncPrint(str: String, myfunc: (String) -> Unit) {    // invoke regular function using local name    myfunc(str)}fun mul(a: Int, b: Int): Int {    return a * b}//higher-order function declarationfun higherfuncMultiply(): ((Int, Int) -> Int) {    return ::mul}fun operation(x: Int, y: Int, mathOperation: (Int, Int) -> Int) {    print(mathOperation(x, y))}fun myOPeration(x:Int, y : Int, mathOperation : (Int, Int) -> Int) : Int{    return mathOperation(x,y)}fun main(args: Array<String>) {    println("------Higher Order Functions in Kotlin------------")    higherfunc1(lambda1)    hugherOrderFun2(lambda2)    hugherOrderFun2(lambda_2)    higherfuncPrint("Print Value using Higher Order function", ::printMe)    val multiply = higherfuncMultiply()    // invokes the mul() function by passing arguments    val result = multiply(2, 4)    println("The multiplication of two numbers is: $result")    val add = { x: Int, y: Int -> x + y }    val sub = { x: Int, y: Int -> x - y }    val mul = { x: Int, y: Int -> x * y }    val div = { x: Int, y: Int -> x / y }    operation(2, 3, add)    operation(2, 3, { x, y -> x + y })    val sumRes = myOPeration(2, 3, { x, y -> x + y })    println("SUM result is $sumRes")    operation(10, 5, sub)    operation(10, 5, { x, y -> x - y })    val subRes = myOPeration(10, 5, { x, y -> x - y })    println("Substraction result is $subRes")    operation(3, 2, mul)    operation(3, 2, { x, y -> x * y })    val mulRes = myOPeration(3, 2, { x, y -> x * y })    println("Multification result is $mulRes")    operation(20, 4, div)    operation(20, 4, { x, y -> x / y })    val devideRes = myOPeration(20, 4, { x, y -> x / y })    println("Devide result is $devideRes")}